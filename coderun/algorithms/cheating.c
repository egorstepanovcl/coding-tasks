
// Решил: Егор Степанов <https://github.com/egorstepanovcl>

// Название: 9. Списывание

// Задача:
// Во время контрольной работы профессор Флойд заметил, что некоторые студенты обмениваются записками. Сначала он хотел поставить им всем двойки, но в тот день профессор был добрым, а потому решил разделить студентов на две группы: списывающих и дающих списывать, и поставить двойки только первым.
// У профессора записаны все пары студентов, обменявшихся записками. Требуется определить, сможет ли он разделить студентов на две группы так, чтобы любой обмен записками осуществлялся от студента одной группы студенту другой группы.

// Формат ввода:
// В первой строке находятся два числа N и M — количество студентов и количество пар студентов, обменивающихся записками (1≤N≤10²,0≤M≤N(N−1)/2).
// Далее в M строках расположены описания пар студентов: два числа, соответствующие номерам студентов, обменивающихся записками (нумерация студентов идёт с 1). Каждая пара студентов перечислена не более одного раза.

// Формат вывода:
// Необходимо вывести ответ на задачу профессора Флойда. Если возможно разделить студентов на две группы - выведите YES; иначе выведите NO.

// Ограничения:
// Ограничение времени: 2 с
// Ограничение памяти: 256 МБ

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 100

int graph[MAX_N + 1][MAX_N + 1]; // Матрица смежности для графа
int color[MAX_N + 1]; // Массив для хранения цветов студентов

int isBipartite(int student, int c, int n) {
    color[student] = c; // Устанавливаем цвет текущему студенту

    for (int i = 1; i <= n; i++) {
        if (graph[student][i]) { // Если есть связь между студентами
            if (color[i] == -1) { // Если соседний студент не раскрашен
                // Рекурсивно раскрашиваем соседнего студента противоположным цветом
                if (!isBipartite(i, 1 - c, n)) {
                    return 0; // Если раскрашивание невозможно, возвращаем 0
                }
            } else if (color[i] == c) { // Если соседний студент имеет тот же цвет
                return 0; // Возвращаем 0, так как это конфликт
            }
        }
    }
    return 1; // Если раскрашивание прошло успешно, возвращаем 1
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    // Инициализация графа и цветов
    memset(graph, 0, sizeof(graph));
    memset(color, -1, sizeof(color));

    // Считываем пары студентов
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        graph[u][v] = 1; // Устанавливаем связь между студентами
        graph[v][u] = 1; // Граф неориентированный
    }

    // Проверка двудольности для всех студентов
    for (int i = 1; i <= n; i++) {
        if (color[i] == -1) { // Если студент еще не раскрашен
            if (!isBipartite(i, 0, n)) {
                printf("NO\n"); // Если невозможно раскрасить, выводим NO
                return 0;
            }
        }
    }
    
    printf("YES\n"); // Если все студенты успешно раскрашены, выводим YES
    return 0;
}

// Решил: Егор Степанов <https://github.com/egorstepanovcl>

// Название: 2. Самый дешевый путь

// Задача:
// В каждой клетке прямоугольной таблицы N×M записано некоторое число. Изначально игрок находится в левой верхней клетке. За один ход ему разрешается перемещаться в соседнюю клетку либо вправо, либо вниз (влево и вверх перемещаться запрещено). При проходе через клетку с игрока берут столько килограммов еды, какое число записано в этой клетке (еду берут также за первую и последнюю клетки его пути).
// Требуется найти минимальный вес еды в килограммах, отдав которую игрок может попасть в правый нижний угол.

// Формат ввода:
// Вводятся два числа N и M — размеры таблицы (1≤N≤20, 1≤M≤20). Затем идет N строк по M чисел в каждой — размеры штрафов в килограммах за прохождение через соответствующие клетки (числа от 0 до 100).

// Формат вывода:
// Выведите минимальный вес еды в килограммах, отдав которую можно попасть в правый нижний угол.

// Ограничения:
// Ограничение времени: 1 с
// Ограничение памяти: 256 МБ

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int main() {
    int N, M; // Размеры сетки
    scanf("%d %d", &N, &M); // Чтение размеров сетки

    int grid[N][M]; // Объявление двумерного массива для хранения значений сетки
    // Чтение значений сетки
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            scanf("%d", &grid[i][j]); // Заполнение массива значениями
        }
    }

    int dp[N][M]; // Объявление массива для хранения минимальных путей
    dp[0][0] = grid[0][0]; // Инициализация начальной точки

    // Заполнение первого ряда (только движение вправо)
    for (int i = 1; i < M; i++) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
    }

    // Заполнение первого столбца (только движение вниз)
    for (int i = 1; i < N; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }

    // Заполнение оставшейся части массива dp
    for (int i = 1; i < N; i++) {
        for (int j = 1; j < M; j++) {
            // Выбираем минимальный путь до текущей ячейки
            dp[i][j] = grid[i][j] + (dp[i - 1][j] < dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1]);
        }
    }

    // Вывод минимальной стоимости пути до правого нижнего угла сетки
    printf("%d\n", dp[N - 1][M - 1]);

    return 0;
}